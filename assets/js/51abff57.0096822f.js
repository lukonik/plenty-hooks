"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[240],{1184:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(4041);const o={},l=s.createContext(o);function r(e){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(l.Provider,{value:n},e.children)}},7662:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"hooks/useInterval","title":"useInterval","description":"useInterval is a React Hook that runs setInterval internally and clears it automatically when the component unmounts. It also keeps the latest version of your callback, so you do not need to memoise it yourself.","source":"@site/docs/hooks/useInterval.md","sourceDirName":"hooks","slug":"/hooks/useInterval","permalink":"/plenty-hooks/docs/hooks/useInterval","draft":false,"unlisted":false,"editUrl":"https://github.com/lukonik/plenty-hooks/tree/main/apps/docs/docs/hooks/useInterval.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"hooks","previous":{"title":"Hooks","permalink":"/plenty-hooks/docs/category/hooks"},"next":{"title":"useTimeout","permalink":"/plenty-hooks/docs/hooks/useTimeout"}}');var o=t(1085),l=t(1184);const r={sidebar_position:3},a="useInterval",i={},c=[{value:"Usage",id:"usage",level:2},{value:"API",id:"api",level:2},{value:"Tips",id:"tips",level:2},{value:"Source",id:"source",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"useinterval",children:"useInterval"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"useInterval"})," is a React Hook that runs ",(0,o.jsx)(n.code,{children:"setInterval"})," internally and clears it automatically when the component unmounts. It also keeps the latest version of your callback, so you do not need to memoise it yourself."]}),"\n",(0,o.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",metastring:'title="Counter.tsx"',children:"import { useState } from 'react';\nimport { useInterval } from 'plenty-hooks';\n\nexport function Counter() {\n  const [count, setCount] = useState(0);\n  const [delay, setDelay] = useState<number | null>(1000);\n\n  useInterval(() => {\n    setCount((current) => current + 1);\n  }, delay);\n\n  return (\n    <>\n      <span>Count: {count}</span>\n      <button onClick={() => setDelay(1000)}>Start</button>\n      <button onClick={() => setDelay(null)}>Stop</button>\n      <button onClick={() => setCount(0)}>Reset</button>\n    </>\n  );\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"api",children:"API"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"useInterval(cb, delay)"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"cb: () => void"})," \u2013 function executed on every tick. The most recent function is always invoked."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"delay: number | null | undefined"})," \u2013 time in milliseconds between ticks. Pass ",(0,o.jsx)(n.code,{children:"null"})," or ",(0,o.jsx)(n.code,{children:"undefined"})," to pause the interval without tearing the hook down."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The hook does not return a value. Cleanup is handled automatically when the component unmounts or when the interval is paused."}),"\n",(0,o.jsx)(n.h2,{id:"tips",children:"Tips"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Pause and resume"}),": Store the delay in state (as in the example above) to start/stop the interval imperatively."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Latest callback"}),": Because ",(0,o.jsx)(n.code,{children:"useInterval"})," stores the latest callback in a ref, you can safely use inline functions without ",(0,o.jsx)(n.code,{children:"useCallback"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Cleanup"}),": You do not need a manual ",(0,o.jsx)(n.code,{children:"clearInterval"}),"; the hook clears it whenever the delay changes or the component leaves the tree."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"source",children:"Source"}),"\n",(0,o.jsx)(n.p,{children:"The hook is self-isolated\u2014you can copy this snippet into your project and it will work out of the box."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { useCallback, useEffect, useRef } from 'react';\n\nexport function useInterval(cb: () => void, delay: number | null | undefined) {\n  const savedCb = useRef(cb);\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const intervalId = useRef<any>(null);\n\n  useEffect(() => {\n    savedCb.current = cb;\n  }, [cb]);\n\n  const clear = useCallback(() => {\n    if (intervalId.current !== null && intervalId.current !== undefined) {\n      clearInterval(intervalId.current);\n      intervalId.current = null;\n    }\n  }, []);\n\n  useEffect(() => {\n    if (delay === null || delay === undefined) {\n      clear();\n      return;\n    }\n\n    intervalId.current = setInterval(() => {\n      savedCb.current();\n    }, delay);\n\n    return () => {\n      clear();\n    };\n  }, [delay, clear]);\n}\n"})})]})}function d(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}}}]);